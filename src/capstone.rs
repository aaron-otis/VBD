#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

// Include FFI function generated by bindgen.
include!(concat!(env!("OUT_DIR"), "/bgen_capstone.rs"));

extern crate libc;

use std::ffi::CStr;
use binary_loader::{Binary, BinaryArch, SymbolType};

/* Disassembles a binary. Currently only supports disassembling the .text section.
 *
 * Input:   A reference to a Binary object, bin.
 * Output:  A string representing disassembled assembly code.
 *
 * Returns an empty string upon encountering an error.
 */
pub fn disassemble(bin: &Binary) -> u32 {
    // Get .text section of the binary.
    let text = match bin.clone().get_text_section() {
        Ok(sec) => sec,
        _ => return cs_err_CS_ERR_OK,
    };

    // Initialize capstone and get the handle for this binary.
    let mut handle = match cap_open(bin) {
        Ok(d) => d,
        Err(_) => return cs_err_CS_ERR_HANDLE,
    };

    unsafe {
        /* Set option to enable detailed disassembly.
         * Note: If using cs_disasm_iter, this option must be set before
         *       calling cs_malloc, otherwise a segfault will occur!
         */
        match cs_option(handle, cs_opt_type_CS_OPT_DETAIL,
                        cs_opt_value_CS_OPT_ON as usize)  {
            cs_err_CS_ERR_OK => (),
            _ => return cs_err_CS_ERR_OPTION,
        }

        let cs_ins: *mut cs_insn = cs_malloc(handle);
        if cs_ins.is_null() {
            return cs_err_CS_ERR_MEM;
        }

        // Create a queue for entry points and add addresses to the queue.
        let mut addr_queue: Vec<(String, u64)> = Vec::new();
        if text.contains(bin.entry) {
            addr_queue.push((".text".to_string(), bin.entry));
        }
        for symbol in bin.symbols.iter() {
            match symbol.sym_type  {
                SymbolType::SymTypeFunc => {
                    if text.contains(symbol.addr) {
                        addr_queue.push((symbol.name.clone(), symbol.addr));
                    };
                },
                _ => (),
            }
        }

        // Remove duplicate addresses.
        addr_queue.sort();
        addr_queue.dedup();

        // Recursive disassembly.
        for (name, addr) in addr_queue.iter_mut() {
            println!("{}: 0x{:016x}", name, addr);
            let offset = *addr - text.vma;
            let mut pc = &mut text.bytes.as_ptr().offset(offset as isize);
            let mut size = (text.size - offset) as usize;

            while cs_disasm_iter(handle, pc, &mut size, addr, cs_ins) {
                if (*cs_ins).id == x86_insn_X86_INS_INVALID || (*cs_ins).size == 0 {
                    break;
                }
                print_ins(*cs_ins);
            }
            print!("\n");
        }

        // Cleanup.
        cs_free(cs_ins, 1);
        cs_close(&mut handle);

        cs_err_CS_ERR_OK
    }
}

/* Wrapper to automatically initialize capstone based on binary attributes.
 * Currently only supports x86 and x86_64.
 *
 * Input:   A reference to a Binary object, bin.
 * Output:  A Result of csh on success and cs_err on failure.
 */
fn cap_open(bin: &Binary) -> Result<csh, cs_err> {
    let arch = match bin.arch {
        BinaryArch:: ArchX86 => cs_arch_CS_ARCH_X86,
        BinaryArch::ArchX86_64 => cs_arch_CS_ARCH_X86,
        //BinaryArch::ArchArm => cs_arch_CS_ARCH_ARM,
        //BinaryArch::ArchArm64 => cs_arch_CS_ARCH_ARM64,
        _ => return Err(cs_err_CS_ERR_ARCH),
    };
    let mode = match bin.bits {
        32 => cs_mode_CS_MODE_32,
        64 => cs_mode_CS_MODE_64,
        _ => cs_mode_CS_MODE_LITTLE_ENDIAN, // Default according to capstone.h.
    };

    let mut handle: csh = 0;
    unsafe {
        match cs_open(arch, mode, &mut handle) {
            cs_err_CS_ERR_OK => Ok(handle),
            e => Err(e),
        }
    }
}

/* Print a single instruction.
 *
 * Input:   A single instruction represented as a cs_insn.
 * Output:  None.
 */
fn print_ins(ins: cs_insn) {
    unsafe {
        print!("0x{:013x} ", ins.address);
        for i in 0..16 {
            if i < ins.size as usize {
                print!("{:02x}", ins.bytes[i]);
            }
            else {
                print!("  ");
            }
        }
        let mnemonic = CStr::from_ptr(ins.mnemonic.as_ptr()).to_string_lossy();
        let op_str = CStr::from_ptr(ins.op_str.as_ptr()).to_string_lossy();
        println!(" {} {}", mnemonic, op_str);
    }
}

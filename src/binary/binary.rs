#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

// Include FFI function generated by bindgen.
include!(concat!(env!("OUT_DIR"), "/bgen_capstone.rs"));

use std::fmt;
use bfd::load_binary;
use std::ffi::CStr;
use super::section::*;
use super::symbol::*;
use super::super::util::print_bytes;
use super::super::capstone;

pub enum LoadError {
    SectionNotFound,
    FileNotFound,
    OpenFileError,
    InvalidFormat,
    UnrecognizedFormat,
    UnsupportedType,
    UnsupportedArch,
    NoSymbols,
    SecReadErr,
}

pub enum BinaryType {
    BinTypeAuto,
    BinTypeELF,
    BinTypePE,
}

pub enum BinaryArch {
    ArchNone,
    ArchX86,
    ArchArm,
    ArchX86_64,
    ArchArm64,
    ArchRISCV,
}

#[derive(Clone)]
pub struct Binary {
    pub filename: String,
    pub bin_type: BinaryType,
    pub type_str: String,
    pub arch: BinaryArch,
    pub arch_str: String,
    pub bits: u32,
    pub entry: u64,
    pub sections: Vec<Section>,
    pub symbols: Vec<Symbol>,
    pub functions: Vec<Function>,
}

pub struct Function {
    pub name: String,
    pub addr: u64,
    pub comment: String,
    pub basic_blocks: Vec<BasicBlock>,
}

pub struct BasicBlock {
    pub instructions: Vec<Instruction>,
}

pub struct Instruction {
    pub instruction: capstone::cs_insn,
}

impl Binary {
    pub fn new<'b>(fname: String) -> Result<Binary, LoadError> {
        match load_binary(fname.clone()) {
            Ok(b) => return Ok(b),
            Err(e) => return Err(e),
        };
    }

    pub fn get_text_section<'c>(self) -> Result<Section, LoadError> {
        for section in self.sections.iter() {
            if section.name == ".text" {
                return Ok(section.clone())
            }
        }
        Err(LoadError::SectionNotFound)
    }

    pub fn is_addr_section(&self, addr: u64) -> Option<String> {
        for section in self.sections.iter() {
            if section.vma == addr {
                return Some(section.name.clone());
            }
        }
        None
    }

    pub fn is_addr_symbol(&self, addr: u64) -> Option<String> {
        for symbol in self.symbols.iter() {
            if symbol.addr == addr {
                return Some(symbol.name.clone());
            }
        }
        None
    }

    pub fn print_symbols(&self) {
        fn print_syms(symbols: &Vec<Symbol>) {
            println!("{:<6} {:<18} {:<4} {:<6} {:<}", "Num", "Value", "Type",
                     "Bind", "Name");
            let mut i = 0;
            for symbol in symbols {

                println!("{:5}: {}", i, symbol);
                i += 1;
            }
        }

        // Sort static and dynamic symbols into their own vectors. Note that there
        // were issues encountered using collec() and so this work around was used.
        let mut dsymtab: Vec<Symbol> = Vec::new();
        let mut ssymtab: Vec<Symbol> = Vec::new();
        for sym in self.symbols.iter() {
            match sym.table {
                SymbolTable::SymTabStatic => ssymtab.push((*sym).clone()),
                SymbolTable::SymTabDynamic => dsymtab.push(sym.clone()),
            };
        }

        println!("Dynamic symbol table:");
        print_syms(&dsymtab);
        println!("\nStatic symbol table:");
        print_syms(&ssymtab);
        print!("\n");
    }

    pub fn print_sections(&self) {
        println!("\nSections:");
        println!("{:24} {:4} {:18} {}", "Name", "Type", "Address", "Size");
        for sec in self.sections.iter() {
            println!("{}", sec);
        }
        print!("\n");
    }

    pub fn print_section_contents(&self) {
        for section in self.sections.iter() {
            println!("{}", section.name);
            print_bytes(&section.bytes);
        }
    }
}

impl fmt::Display for Binary {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut b_str = String::new();
        for function in self.functions.iter() {
            b_str.push_str(&format!("{}\n", function));
        }
        write!(f, "{}", b_str)
    }
}

impl Function {
}

impl Clone for Function {
    fn clone (&self) -> Function {
        Function{
            name: self.name.clone(),
            addr: self.addr,
            comment: self.comment.clone(),
            basic_blocks: self.basic_blocks.clone(),
        }
    }
}

impl fmt::Display for Function {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let bb_str = self.basic_blocks.iter()
                                      .map(|ref ins| format!("{}", ins))
                                      .collect::<Vec<String>>()
                                      .join("\n\t|\n\tv\n");
        write!(f, "{}\n{}\n", self.comment, bb_str)
    }
}

impl Clone for BasicBlock {
    fn clone (&self) -> BasicBlock {
        BasicBlock {instructions: self.instructions.clone()}
    }
}

impl fmt::Display for BasicBlock {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let bb_str = self.instructions.iter()
                                      .map(Instruction::to_string)
                                      .collect::<Vec<String>>()
                                      .join("\n");
        write!(f, "{}", bb_str)
    }
}

impl Instruction {
    pub fn new(ins: capstone::cs_insn) -> Instruction {
        Instruction{instruction: ins}
    }
}

impl Clone for Instruction {
    fn clone (&self) -> Instruction {
        Instruction{instruction: self.instruction.clone()}
    }
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut ins_str = String::new();

        unsafe {
            ins_str.push_str(&format!("0x{:013x} ", self.instruction.address));
            for i in 0..16 {
                if i < self.instruction.size as usize {
                    ins_str.push_str(&format!("{:02x}", self.instruction.bytes[i]));
                }
                else {
                    ins_str.push_str(&format!("  "));
                }
            }
            let mnemonic = CStr::from_ptr(self.instruction.mnemonic.as_ptr())
                                 .to_string_lossy();
            let op_str = CStr::from_ptr(self.instruction.op_str.as_ptr())
                               .to_string_lossy();
            ins_str.push_str(&format!(" {} {}", mnemonic, op_str));
        }

        write!(f, "{}", ins_str)
    }
}

impl Clone for BinaryType {
    fn clone (&self) -> BinaryType {
        match self {
            BinaryType::BinTypeAuto => BinaryType::BinTypeAuto,
            BinaryType::BinTypeELF => BinaryType::BinTypeELF,
            BinaryType::BinTypePE => BinaryType::BinTypePE,
        }
    }
}

impl Clone for BinaryArch {
    fn clone (&self) -> BinaryArch {
        match self {
            BinaryArch::ArchNone => BinaryArch::ArchNone,
            BinaryArch::ArchX86 => BinaryArch::ArchX86,
            BinaryArch::ArchArm => BinaryArch::ArchArm,
            BinaryArch::ArchX86_64 => BinaryArch::ArchX86_64,
            BinaryArch::ArchArm64 => BinaryArch::ArchArm64,
            BinaryArch::ArchRISCV => BinaryArch::ArchRISCV,
        }
    }
}
